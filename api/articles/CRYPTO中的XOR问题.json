{"title":"CRYPTO中的XOR问题","slug":"CRYPTO中的XOR问题","date":"2025-02-02T04:53:40.000Z","updated":"2025-02-04T11:49:33.696Z","comments":true,"path":"api/articles/CRYPTO中的XOR问题.json","photos":[],"excerpt":null,"covers":["/../images/image-20250204192002493.png","/../images/image-20250204193936704.png"],"content":"<p>XOR是CTFer在做题中常见的问题，本文分享一下我在做题过程中遇到的经典问题</p>\n<h2 id=\"什么是XOR\"><a href=\"#什么是XOR\" class=\"headerlink\" title=\"什么是XOR\"></a>什么是XOR</h2><p>XOR即”异或运算“，它在数学表达式中常常写作’’⊕’’，在常见的几种编程语言中，则是用符号’’^’’来表示。</p>\n<p>XOR运算遵循这样的规则：</p>\n<p>1⊕1 &#x3D; 0</p>\n<p>0⊕0 &#x3D; 0</p>\n<p>1⊕0 &#x3D; 1</p>\n<p>0⊕1 &#x3D; 1</p>\n<p>在实际运算中，它是按位运算的。现有二进制10010和11001，二者异或的结果为01011。</p>\n<h2 id=\"XOR的运算性质\"><a href=\"#XOR的运算性质\" class=\"headerlink\" title=\"XOR的运算性质\"></a>XOR的运算性质</h2><p>XOR运算具有</p>\n<p>1）交换律</p>\n<p>2）结合律</p>\n<p>3）归零律：A⊕A&#x3D;0</p>\n<p>4）恒等律：A⊕0&#x3D;A</p>\n<p>由其归零率和恒等率我们还可以推出：</p>\n<p>A⊕B&#x3D;C</p>\n<p>即A⊕B⊕B&#x3D;C⊕B</p>\n<p>即A&#x3D;C⊕B</p>\n<p>这就说明了为什么单单使用XOR，属于对称密码。假设A是密文，B是密钥，经过上面的步骤可以看出只要知道密钥B，就能将密文和明文相互转化。</p>\n<h2 id=\"XOR题型举例\"><a href=\"#XOR题型举例\" class=\"headerlink\" title=\"XOR题型举例\"></a>XOR题型举例</h2><h3 id=\"利用运算性质\"><a href=\"#利用运算性质\" class=\"headerlink\" title=\"利用运算性质\"></a>利用运算性质</h3><p><em>本题来源于cryptohack</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KEY1 = a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313</span><br><span class=\"line\">KEY2 ^ KEY1 = 37dcb292030faa90d07eec17e3b1c6d8daf94c35d4c9191a5e1e</span><br><span class=\"line\">KEY2 ^ KEY3 = c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1</span><br><span class=\"line\">FLAG ^ KEY1 ^ KEY3 ^ KEY2 = 04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf </span><br></pre></td></tr></table></figure>\n\n<p>求FLAG只需让4式异或1式和3式</p>\n<p>python实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">KEY1 = <span class=\"built_in\">bytes</span>.fromhex(<span class=\"string\">&#x27;a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313&#x27;</span>)</span><br><span class=\"line\">KEY2_KEY1 = <span class=\"built_in\">bytes</span>.fromhex(<span class=\"string\">&#x27;37dcb292030faa90d07eec17e3b1c6d8daf94c35d4c9191a5e1e&#x27;</span>)</span><br><span class=\"line\">KEY2_KEY3 = <span class=\"built_in\">bytes</span>.fromhex(<span class=\"string\">&#x27;c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1&#x27;</span>)</span><br><span class=\"line\">FLAG_KEY1_KEY3_KEY2 = <span class=\"built_in\">bytes</span>.fromhex(<span class=\"string\">&#x27;04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf&#x27;</span>)</span><br><span class=\"line\">step1 = xor(FLAG_KEY1_KEY3_KEY2,KEY1)</span><br><span class=\"line\">step2 = xor(step1,KEY2_KEY3)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(step2)</span><br></pre></td></tr></table></figure>\n\n<p>注：1. 使用了pwntools库中的xor()函数</p>\n<p>​\t\t2.bytes.fromhex()函数的作用是将十六进制字符组成的字符串转化为字节序列，即’a6c8b6’转化为0xa6 0xc8 0xb6的序列</p>\n<h3 id=\"碰撞已知的明文片段\"><a href=\"#碰撞已知的明文片段\" class=\"headerlink\" title=\"碰撞已知的明文片段\"></a>碰撞已知的明文片段</h3><p><img src=\"/../images/image-20250204192002493.png\" alt=\"image-20250204192002493\"></p>\n<p>本题我们已知密钥仅为一个字节，又知道最终flag为crypto{xxxxxx}的形式</p>\n<p>根据XOR运算的性质，我们只需要让密文首个字节与字母’c’异或，就能得到密钥</p>\n<p>python实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import *</span><br><span class=\"line\">m = &#x27;73626960647f6b206821204f21254f7d694f7624662065622127234f726927756d&#x27;</span><br><span class=\"line\">m_bytes = bytes.fromhex(m)</span><br><span class=\"line\">key = xor(0x73,&#x27;c&#x27;)</span><br><span class=\"line\">print(key)</span><br><span class=\"line\">p = xor(m_bytes,key)</span><br><span class=\"line\">print(p)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对图片的XOR\"><a href=\"#对图片的XOR\" class=\"headerlink\" title=\"对图片的XOR\"></a><em>对图片的XOR</em></h3><p>基本原理：图片由许多像素点排列组成，我们可以把每个像素点的灰度或RGB(red,green,blue,可以认为每个像素点的颜色是由这三种颜色不同比例混合而成的)的数值当作异或的对象。将异或得到的数值再转化为灰度或RGB，形成新的图片。</p>\n<p>常用的工具：python的PIL库</p>\n<p>例题来自cryptohack，感兴趣可自行查看</p>\n<p><img src=\"/../images/image-20250204193936704.png\" alt=\"image-20250204193936704\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from PIL import Image</span><br><span class=\"line\">image1 = Image.open(&quot;F:\\pythonscript\\cryptohack\\Lemur_XOR\\lemur_ed66878c338e662d3473f0d98eedbd0d.png&quot;)</span><br><span class=\"line\">image2 = Image.open(&quot;F:\\pythonscript\\cryptohack\\Lemur_XOR\\\\flag_7ae18c704272532658c10b5faad06d74.png&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">#生成可操作的对象，pim类似于矩阵，通过坐标值来操控每个像素</span><br><span class=\"line\">pim1 = image1.load()</span><br><span class=\"line\">pim2 = image2.load()</span><br><span class=\"line\"></span><br><span class=\"line\">width,height=image1.size</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(width):</span><br><span class=\"line\">    for j in range(height):</span><br><span class=\"line\">        r1,g1,b1 = pim1[i,j]</span><br><span class=\"line\">        r2,g2,b2 = pim2[i,j]</span><br><span class=\"line\">        pim1[i,j] = (r1^r2, g1^g2, b1^b2)</span><br><span class=\"line\"></span><br><span class=\"line\">image1.show()</span><br></pre></td></tr></table></figure>\n\n<p>注：Image.open()函数即打开图片文件</p>\n<p>​\t\t.load()函数生成一个矩阵，通过坐标值来访问图片中的每个像素</p>\n<p>​\t\t.size能分别得出图片的宽和高（像素点个数）</p>\n<p>​\t\tr1,g1,b1 &#x3D; pim1[i,j]这一句是得到[i,j]位置处的RGB值</p>\n<p>​\t\t.show()函数负责弹窗展示图片</p>\n<p>感觉这一题更像是misc会出的东西。</p>\n","categories":[],"tags":[]}