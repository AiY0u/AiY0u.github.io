{"title":"CRYPTO中的数论基础（更新中）","slug":"CRYPTO中的数论基础（更新中）","date":"2025-02-03T04:52:07.000Z","updated":"2025-02-05T07:31:53.627Z","comments":true,"path":"api/articles/CRYPTO中的数论基础（更新中）.json","photos":[],"excerpt":null,"covers":null,"content":"<p>本文持续更新中</p>\n<h2 id=\"数论简介：\"><a href=\"#数论简介：\" class=\"headerlink\" title=\"数论简介：\"></a>数论简介：</h2><p><a href=\"https://baike.baidu.com/item/%E6%95%B0%E8%AE%BA/3700\">数论（number theory），是纯粹数学的分支之一，主要研究整数的性质。</a></p>\n<h2 id=\"模运算\"><a href=\"#模运算\" class=\"headerlink\" title=\"模运算\"></a>模运算</h2><h3 id=\"1-模运算规则\"><a href=\"#1-模运算规则\" class=\"headerlink\" title=\"1. 模运算规则\"></a>1. 模运算规则</h3><p><strong>a mod b    (b&gt;0，且a,b均为整数)</strong>   相当于许多编程语言中的<strong>a % b</strong>,表示a作为被除数，b作为除数时，计算所得到的<strong>余数</strong></p>\n<p>这里强调,除数b必须是正整数，而被除数a可以是负整数</p>\n<h3 id=\"2-整除的概念\"><a href=\"#2-整除的概念\" class=\"headerlink\" title=\"2. 整除的概念\"></a>2. 整除的概念</h3><p>如果a mod b&#x3D; 0，则称b整除a，记作b|a</p>\n<p>如：15&#x2F;5&#x3D;3，则5|15</p>\n<h3 id=\"3-模运算举例\"><a href=\"#3-模运算举例\" class=\"headerlink\" title=\"3. 模运算举例\"></a>3. 模运算举例</h3><p>15点是下午3点，19点是晚上7点，这其实就运用了模运算（x mod 12）</p>\n<p>a为负整数时怎么算呢？</p>\n<p>例如：-11 mod 4</p>\n<p>我们可以让-11不停加上4</p>\n<p>-11+4&#x3D;-7，-7+4&#x3D;-3，-3+4&#x3D;1</p>\n<p>所以-11 mod 4 &#x3D; 1（即-11&#x3D;4*(-3)+1）</p>\n<h2 id=\"最大公约数\"><a href=\"#最大公约数\" class=\"headerlink\" title=\"最大公约数\"></a>最大公约数</h2><h3 id=\"1-公约数和最大公约数的概念\"><a href=\"#1-公约数和最大公约数的概念\" class=\"headerlink\" title=\"1.公约数和最大公约数的概念\"></a>1.公约数和最大公约数的概念</h3><p><strong>设整数a,b 如果存在整数d,使d|a,d|b,则称d是a和b的公因子(或公约数)</strong></p>\n<p><strong>如果  <em>d&gt;0</em>  ,且a和b的所有公因子都整除d,则称d是a和b的  <em>最大公约数</em>  ，记作gcd(a,b)</strong></p>\n<p>哎为什么这里没有限制公因子是正整数还是负整数嘞？</p>\n<p>因为<strong>公因子可正可负可为0</strong>！</p>\n<p>3和6的公因子:+1,-1,+3,-3</p>\n<p>其中gcd(3,6) &#x3D; 3  </p>\n<p>再有就是说，求最大公约数时可以把负号直接去掉来求:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcd(-3,6) = gcd(3,6) = 3 ; gcd(-3,-6) = gcd(3,6) = 3</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"互素\"><a href=\"#互素\" class=\"headerlink\" title=\"互素\"></a>互素</h2><p>定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果gcb(a,b) = 1,称a和b互素</span><br></pre></td></tr></table></figure>\n\n<p>存在这样一个定理:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果gcd(a,b) = d，那么存在整数m,n 使得a=md,b=nd,且gcd(m,n)=1</span><br></pre></td></tr></table></figure>\n\n<p>例如gcd(4,6)&#x3D;2 ,m&#x3D;2,n&#x3D;3,m和n互质</p>\n<p>证明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果gcd(m,n)=t &gt;1，</span><br><span class=\"line\">即m,n有大于1的公约数</span><br><span class=\"line\">那么gcd(a,b)=td,</span><br><span class=\"line\">与gcd(a,b)=d矛盾</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"欧几里得算法-辗转相除法-计算最大公约数\"><a href=\"#欧几里得算法-辗转相除法-计算最大公约数\" class=\"headerlink\" title=\"欧几里得算法(辗转相除法)计算最大公约数\"></a>欧几里得算法(辗转相除法)计算最大公约数</h2><h3 id=\"欧几里得算法的原理\"><a href=\"#欧几里得算法的原理\" class=\"headerlink\" title=\"欧几里得算法的原理\"></a><strong>欧几里得算法的原理</strong></h3><p>不妨设a&gt;&#x3D;b&gt;&#x3D;0</p>\n<p>1.b&#x3D;0时,gcd(a,0)&#x3D;a     <em>任何数都是0的因子，所以这里是a</em></p>\n<p>2.b!&#x3D;0时，求gcd(a,b)，许多情况下我们可以写出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=q*b+r</span><br></pre></td></tr></table></figure>\n\n<p>​\t假设gcd(a,b)&#x3D;t, 那么上式写为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m*t=q*n*t+r</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r=(m-q*n)t</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>由此得到：t也是余数r的因子。这个结论对a和b的任意因子都成立，显然也对最大公因子成立</p>\n<p>所以我们知道</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcd(a,b)=gcd(b,r)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"计算过程\"><a href=\"#计算过程\" class=\"headerlink\" title=\"计算过程\"></a>计算过程</h3><p>通过不断缩小问题规模，把求两个数的最大公约数转化为更简单的情况。</p>\n<ol>\n<li>若较小的数是0，答案就是较大的数<ul>\n<li>比如求gcd(8,0)&#x3D;8，因为所有数都能整除0</li>\n</ul>\n</li>\n<li>若两数都不为0，用除法转换问题：<ul>\n<li>用大数除以小数：70 ÷ 15 &#x3D; 4 余 10（写作70 &#x3D; 4×15 +10）</li>\n<li>此时gcd(70,15) &#x3D; gcd(15,10)（关键转换！）</li>\n<li>继续对新数对重复这个过程</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"实操\"><a href=\"#实操\" class=\"headerlink\" title=\"实操\"></a><strong>实操</strong></h3><p>​\tgcd(70,15)&#x3D;gcd(15,10)&#x3D;gcd(10,5)&#x3D;gcd(5,0)&#x3D;5</p>\n<ol>\n<li>70 ÷ 15 &#x3D; 4 余10 → 转为求gcd(15,10)</li>\n<li>15 ÷ 10 &#x3D; 1 余5 → 转为求gcd(10,5)</li>\n<li>10 ÷ 5 &#x3D; 2 余0 → 转为求gcd(5,0)</li>\n<li>出现0时，答案就是剩下的5</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">gcd</span>(<span class=\"params\">a,b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">while</span> b!=<span class=\"number\">0</span>:</span><br><span class=\"line\">        t = a % b</span><br><span class=\"line\">        a = b</span><br><span class=\"line\">        b = t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\">a = ？</span><br><span class=\"line\">b = ？</span><br><span class=\"line\"><span class=\"built_in\">print</span>(gcd(a,b))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"扩展的欧几里得算法\"><a href=\"#扩展的欧几里得算法\" class=\"headerlink\" title=\"扩展的欧几里得算法\"></a>扩展的欧几里得算法</h2><p><strong>扩展欧几里得算法</strong>是欧几里得算法的升级版，它不仅计算两个数的最大公约数（GCD），还能找到一组关键系数（称为<strong>贝祖系数</strong>），使得这两个数的线性组合等于它们的最大公约数。</p>\n<h3 id=\"贝祖定理：\"><a href=\"#贝祖定理：\" class=\"headerlink\" title=\"贝祖定理：\"></a><strong>贝祖定理</strong>：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">若 d=gcd⁡(a,b)，则存在整数 s,t使得 as+bt=d</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><pre><code>- 特别地，若 gcd⁡(a,b)=1，则方程 as+bt=1 有解（即 a 和 b 互质时存在逆元）。\n- 推论：方程 as+bt=v 有解当且仅当 d∣v（即 v 是 d 的倍数）。\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">而扩展的欧几里得算法就是用来计算上述定理中的s和t</span><br><span class=\"line\"></span><br><span class=\"line\">### 原理：</span><br><span class=\"line\"></span><br><span class=\"line\">根据欧几里得算法的逆过程，这里以gcd(70,15)为例</span><br><span class=\"line\"></span><br><span class=\"line\">前文已经写出了欧几里得算法的过程，我们只需根据它一步一步回代</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n5=15×1−10×1\n</code></pre>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>其中 10&#x3D;70×1+15×(−4)，代入得：</p>\n<p>5&#x3D;15×1−(70×1+15×(−4))×1&#x3D;70×(−1)+15×5</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 代码实现</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>def extended_gcd(a, b):<br>    if b &#x3D;&#x3D; 0:<br>        return (a, 1, 0)<br>    else:<br>        d, s_prime, t_prime &#x3D; extended_gcd(b, a % b)<br>        s &#x3D; t_prime<br>        t &#x3D; s_prime - (a &#x2F;&#x2F; b) * t_prime<br>        return (d, s, t)</p>\n<h1 id=\"示例：计算-70s-15t-5\"><a href=\"#示例：计算-70s-15t-5\" class=\"headerlink\" title=\"示例：计算 70s + 15t &#x3D; 5\"></a>示例：计算 70s + 15t &#x3D; 5</h1><p>d, s, t &#x3D; extended_gcd(70, 15)<br>print(f”gcd(70,15)&#x3D;{d}, 系数 s&#x3D;{s}, t&#x3D;{t}”)</p>\n<pre><code>\n==============================================================================================\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t施工区域\n\n## 最小公倍数\n\n引入：天干地支纪年法中，天干有10个，地支有12个\n\n我们知道60年1甲子，天干循环一次周期是10，地支循环周期是12；\n\n从一次出现甲子到下一次出现甲子，不仅需要天干中出现甲，地支中出现子，则刚好需要天干循环整数次，地支循环整数次，显然，这就变成了一个最小公倍数问题，每60年能让天干循环6次，地支循环5次\n$$\n设a,b∈Z，如果m∈Z分别是a和b的倍数，m称为a和b的公倍数\n$$\n\n$$\na,b≠0，如果m是所有正的公倍数中最小的，那么m叫做a和b的最小公倍数，记为m=lcm(a,b)\n$$\n\n$$\n如果a=0或者b=0：lcm(a,b)=0\n$$\n\n**lcm(a,b)=ab/gcd(a,b)**\n</code></pre>\n","categories":[],"tags":[]}