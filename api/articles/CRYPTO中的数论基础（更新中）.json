{"title":"CRYPTO中的数论基础（更新中）","slug":"CRYPTO中的数论基础（更新中）","date":"2025-02-03T04:52:07.000Z","updated":"2025-02-08T07:52:51.022Z","comments":true,"path":"api/articles/CRYPTO中的数论基础（更新中）.json","photos":[],"excerpt":null,"covers":["/../images/image-20250207182502113.png","/../images/image-20250208144201545.png"],"content":"<p>本文持续更新中</p>\n<h2 id=\"数论简介：\"><a href=\"#数论简介：\" class=\"headerlink\" title=\"数论简介：\"></a>数论简介：</h2><p><a href=\"https://baike.baidu.com/item/%E6%95%B0%E8%AE%BA/3700\">数论（number theory），是纯粹数学的分支之一，主要研究整数的性质。</a></p>\n<h2 id=\"模运算\"><a href=\"#模运算\" class=\"headerlink\" title=\"模运算\"></a>模运算</h2><h3 id=\"1-模运算规则\"><a href=\"#1-模运算规则\" class=\"headerlink\" title=\"1. 模运算规则\"></a>1. 模运算规则</h3><p><strong>a mod b    (b&gt;0，且a,b均为整数)</strong>   相当于许多编程语言中的<strong>a % b</strong>,表示a作为被除数，b作为除数时，计算所得到的<strong>余数</strong></p>\n<p>这里强调,除数b必须是正整数，而被除数a可以是负整数</p>\n<h3 id=\"2-整除的概念\"><a href=\"#2-整除的概念\" class=\"headerlink\" title=\"2. 整除的概念\"></a>2. 整除的概念</h3><p>如果a mod b&#x3D; 0，则称b整除a，记作b|a</p>\n<p>如：15&#x2F;5&#x3D;3，则5|15</p>\n<h3 id=\"3-模运算举例\"><a href=\"#3-模运算举例\" class=\"headerlink\" title=\"3. 模运算举例\"></a>3. 模运算举例</h3><p>15点是下午3点，19点是晚上7点，这其实就运用了模运算（x mod 12）</p>\n<p>a为负整数时怎么算呢？</p>\n<p>例如：-11 mod 4</p>\n<p>我们可以让-11不停加上4</p>\n<p>-11+4&#x3D;-7，-7+4&#x3D;-3，-3+4&#x3D;1</p>\n<p>所以-11 mod 4 &#x3D; 1（即-11&#x3D;4*(-3)+1）</p>\n<h2 id=\"最大公约数\"><a href=\"#最大公约数\" class=\"headerlink\" title=\"最大公约数\"></a>最大公约数</h2><h3 id=\"1-公约数和最大公约数的概念\"><a href=\"#1-公约数和最大公约数的概念\" class=\"headerlink\" title=\"1.公约数和最大公约数的概念\"></a>1.公约数和最大公约数的概念</h3><p><strong>设整数a,b 如果存在整数d,使d|a,d|b,则称d是a和b的公因子(或公约数)</strong></p>\n<p><strong>如果  <em>d&gt;0</em>  ,且a和b的所有公因子都整除d,则称d是a和b的  <em>最大公约数</em>  ，记作gcd(a,b)</strong></p>\n<p>哎为什么这里没有限制公因子是正整数还是负整数嘞？</p>\n<p>因为<strong>公因子可正可负可为0</strong>！</p>\n<p>3和6的公因子:+1,-1,+3,-3</p>\n<p>其中gcd(3,6) &#x3D; 3  </p>\n<p>再有就是说，求最大公约数时可以把负号直接去掉来求:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcd(-3,6) = gcd(3,6) = 3 ; gcd(-3,-6) = gcd(3,6) = 3</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"互素\"><a href=\"#互素\" class=\"headerlink\" title=\"互素\"></a>互素</h2><p>定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果gcb(a,b) = 1,称a和b互素</span><br></pre></td></tr></table></figure>\n\n<p>存在这样一个定理:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果gcd(a,b) = d，那么存在整数m,n 使得a=md,b=nd,且gcd(m,n)=1</span><br></pre></td></tr></table></figure>\n\n<p>例如gcd(4,6)&#x3D;2 ,m&#x3D;2,n&#x3D;3,m和n互质</p>\n<p>证明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果gcd(m,n)=t &gt;1，</span><br><span class=\"line\">即m,n有大于1的公约数</span><br><span class=\"line\">那么gcd(a,b)=td,</span><br><span class=\"line\">与gcd(a,b)=d矛盾</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"欧几里得算法-辗转相除法-计算最大公约数\"><a href=\"#欧几里得算法-辗转相除法-计算最大公约数\" class=\"headerlink\" title=\"欧几里得算法(辗转相除法)计算最大公约数\"></a>欧几里得算法(辗转相除法)计算最大公约数</h2><h3 id=\"欧几里得算法的原理\"><a href=\"#欧几里得算法的原理\" class=\"headerlink\" title=\"欧几里得算法的原理\"></a><strong>欧几里得算法的原理</strong></h3><p>不妨设a&gt;&#x3D;b&gt;&#x3D;0</p>\n<p>1.b&#x3D;0时,gcd(a,0)&#x3D;a     <em>任何数都是0的因子，所以这里是a</em></p>\n<p>2.b!&#x3D;0时，求gcd(a,b)，许多情况下我们可以写出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=q*b+r</span><br></pre></td></tr></table></figure>\n\n<p>​\t假设gcd(a,b)&#x3D;t, 那么上式写为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m*t=q*n*t+r</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r=(m-q*n)t</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>由此得到：t也是余数r的因子。这个结论对a和b的任意因子都成立，显然也对最大公因子成立</p>\n<p>所以我们知道</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcd(a,b)=gcd(b,r)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"计算过程\"><a href=\"#计算过程\" class=\"headerlink\" title=\"计算过程\"></a>计算过程</h3><p>通过不断缩小问题规模，把求两个数的最大公约数转化为更简单的情况。</p>\n<ol>\n<li>若较小的数是0，答案就是较大的数<ul>\n<li>比如求gcd(8,0)&#x3D;8，因为所有数都能整除0</li>\n</ul>\n</li>\n<li>若两数都不为0，用除法转换问题：<ul>\n<li>用大数除以小数：70 ÷ 15 &#x3D; 4 余 10（写作70 &#x3D; 4×15 +10）</li>\n<li>此时gcd(70,15) &#x3D; gcd(15,10)（关键转换！）</li>\n<li>继续对新数对重复这个过程</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"实操\"><a href=\"#实操\" class=\"headerlink\" title=\"实操\"></a><strong>实操</strong></h3><p>​\tgcd(70,15)&#x3D;gcd(15,10)&#x3D;gcd(10,5)&#x3D;gcd(5,0)&#x3D;5</p>\n<ol>\n<li>70 ÷ 15 &#x3D; 4 余10 → 转为求gcd(15,10)</li>\n<li>15 ÷ 10 &#x3D; 1 余5 → 转为求gcd(10,5)</li>\n<li>10 ÷ 5 &#x3D; 2 余0 → 转为求gcd(5,0)</li>\n<li>出现0时，答案就是剩下的5</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">gcd</span>(<span class=\"params\">a,b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">while</span> b!=<span class=\"number\">0</span>:</span><br><span class=\"line\">        t = a % b</span><br><span class=\"line\">        a = b</span><br><span class=\"line\">        b = t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\">a = ？</span><br><span class=\"line\">b = ？</span><br><span class=\"line\"><span class=\"built_in\">print</span>(gcd(a,b))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"扩展的欧几里得算法\"><a href=\"#扩展的欧几里得算法\" class=\"headerlink\" title=\"扩展的欧几里得算法\"></a>扩展的欧几里得算法</h2><p><strong>扩展欧几里得算法</strong>是欧几里得算法的升级版，它不仅计算两个数的最大公约数（GCD），还能找到一组关键系数（称为<strong>贝祖系数</strong>），使得这两个数的线性组合等于它们的最大公约数。</p>\n<h3 id=\"贝祖定理：\"><a href=\"#贝祖定理：\" class=\"headerlink\" title=\"贝祖定理：\"></a><strong>贝祖定理</strong>：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">若 d=gcd⁡(a,b)，则存在整数 s,t使得 as+bt=d</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">特别地，若 gcd⁡(a,b)=1，则方程 as+bt=1 有解（即 a 和 b 互质时存在逆元）。</span><br><span class=\"line\">推论：方程 as+bt=v 有解当且仅当 d∣v（即 v 是 d 的倍数）。</span><br></pre></td></tr></table></figure>\n\n<p>而扩展的欧几里得算法就是用来计算上述定理中的s和t</p>\n<h3 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h3><p>根据欧几里得算法的逆过程，这里以gcd(70,15)为例</p>\n<p>前文已经写出了欧几里得算法的过程，我们只需根据它一步一步回代</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5=15×1−10×1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中 10=70×1+15×(−4)，代入得：</span><br><span class=\"line\"></span><br><span class=\"line\">5=15×1−(70×1+15×(−4))×1=70×(−1)+15×5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def extended_gcd(a, b):</span><br><span class=\"line\">    if b == 0:</span><br><span class=\"line\">        return (a, 1, 0)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        d, s_prime, t_prime = extended_gcd(b, a % b)</span><br><span class=\"line\">        s = t_prime</span><br><span class=\"line\">        t = s_prime - (a // b) * t_prime</span><br><span class=\"line\">        return (d, s, t)</span><br><span class=\"line\"></span><br><span class=\"line\">d, s, t = extended_gcd(70, 15)</span><br><span class=\"line\">print(f&quot;gcd(70,15)=&#123;d&#125;, 系数 s=&#123;s&#125;, t=&#123;t&#125;&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t施工区域</p>\n<h2 id=\"最小公倍数\"><a href=\"#最小公倍数\" class=\"headerlink\" title=\"最小公倍数\"></a>最小公倍数</h2><p>引入：天干地支纪年法中，天干有10个，地支有12个</p>\n<p>我们知道60年1甲子，天干循环一次周期是10，地支循环周期是12；</p>\n<p>从一次出现甲子到下一次出现甲子，不仅需要天干中出现甲，地支中出现子，则刚好需要天干循环整数次，地支循环整数次，显然，这就变成了一个最小公倍数问题，每60年能让天干循环6次，地支循环5次<br>$$<br>设a,b∈Z，如果m∈Z分别是a和b的倍数，m称为a和b的公倍数<br>$$</p>\n<p>$$<br>a,b≠0，如果m是所有正的公倍数中最小的，那么m叫做a和b的最小公倍数，记为m&#x3D;lcm(a,b)<br>$$</p>\n<p>$$<br>如果a&#x3D;0或者b&#x3D;0：lcm(a,b)&#x3D;0<br>$$</p>\n<p><strong>lcm(a,b)&#x3D;ab&#x2F;gcd(a,b)</strong></p>\n<h2 id=\"同余\"><a href=\"#同余\" class=\"headerlink\" title=\"同余\"></a>同余</h2><h2 id=\"费马小定理\"><a href=\"#费马小定理\" class=\"headerlink\" title=\"费马小定理\"></a>费马小定理</h2><h2 id=\"模逆元\"><a href=\"#模逆元\" class=\"headerlink\" title=\"模逆元\"></a>模逆元</h2><h2 id=\"二次剩余\"><a href=\"#二次剩余\" class=\"headerlink\" title=\"二次剩余\"></a>二次剩余</h2><p>一个整数x对另一个整数p的二次剩余指的是计算x² mod p的结果（x的平方除以p得到的余数）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当存在一个整数x使得x² ≡ a mod p,称a是模p的二次剩余</span><br><span class=\"line\"></span><br><span class=\"line\">当不存在一个整数x使得x² ≡ a mod p,称a是模p的二次非剩余</span><br></pre></td></tr></table></figure>\n\n<p>它还有这样的运算性质：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二次剩余 * 二次剩余 = 二次剩余</span><br><span class=\"line\"></span><br><span class=\"line\">二次剩余 * 二次非剩余 = 二次非剩余</span><br><span class=\"line\"></span><br><span class=\"line\">二次非剩余 * 二次非剩余 = 二次剩余</span><br></pre></td></tr></table></figure>\n\n<p>检验整数是否是二次剩余参见下文勒让德符号</p>\n<h2 id=\"勒让德符号\"><a href=\"#勒让德符号\" class=\"headerlink\" title=\"勒让德符号\"></a>勒让德符号</h2><p><strong>勒让德符号(Legendre Symbol)<strong>提供了一种有效的方法来确定整数a是否是模</strong>奇数素数p</strong>的二次余数 </p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%8B%92%E8%AE%A9%E5%BE%B7%E7%AC%A6%E5%8F%B7\">勒让德符号-维基百科</a></p>\n<p><img src=\"/../images/image-20250207182502113.png\" alt=\"image-20250207182502113\"></p>\n<p>以cryptohack中的题目为例：</p>\n<p>题目要求：</p>\n<p>Now for the flag. Given the following 1024 bit prime and 10 integers,  find the quadratic residue and then calculate its square root; the  square root is your flag. Of the two possible roots, submit the larger  one as your answer.</p>\n<p>给定1024bit的质数和10个整数，找到二次剩余并且计算它的模平方根，取较大的一个作为flag</p>\n<p><img src=\"/../images/image-20250208144201545.png\" alt=\"image-20250208144201545\"></p>\n<p>我们首先根据勒让德符号，得到哪一个整数是二次剩余。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139</span><br><span class=\"line\">ints = []#篇幅有限，省略掉了</span><br><span class=\"line\">for i in ints:</span><br><span class=\"line\">    a_p = pow(i,(p-1)//2,p)</span><br><span class=\"line\">    if(a_p == 1):</span><br><span class=\"line\">        print(i)</span><br><span class=\"line\">        a = i</span><br><span class=\"line\">print(a,&quot;为二次剩余&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>这里提一句，python判断是否是二次剩余的写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if pow(n,(p-1)//2,p) == 1:</span><br><span class=\"line\">\tprint(&quot;二次剩余&quot;)</span><br><span class=\"line\">if pow(n,(p-1)//2,p) == p - 1:</span><br><span class=\"line\">\tprint(&quot;二次非剩余&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>第三行写的是p-1，因为python的<strong>pow函数计算结果不会为负。</strong></p>\n<p>之后求它的模平方根，需要用到一定的代数运算。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#求a模p意义下的平方根</span><br><span class=\"line\">#因为a**[(p-1)/2] ≡ 1 (mod p)</span><br><span class=\"line\">#所以a**[(p+1)/2] ≡ a (mod p)</span><br><span class=\"line\">#所以a**[(p+1)/4] ≡ a**(1/2) (mod p)</span><br><span class=\"line\"># 计算a**[(p+1)/4] mod p</span><br><span class=\"line\">print(pow(a,(p+1)//4,p))</span><br><span class=\"line\">#注意这里需要确定(p+1)/4是整数，即p mod 4 = 3</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tonelli-Shanks算法\"><a href=\"#Tonelli-Shanks算法\" class=\"headerlink\" title=\"Tonelli-Shanks算法\"></a>Tonelli-Shanks算法</h2><p>**Tonelli-Shanks算法(托内利-尚克斯算法)**可以计算模素数下的平方根。</p>\n<p>python实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def legendre_symbol(a, p):</span><br><span class=\"line\">    &quot;&quot;&quot;计算勒让德符号 (a/p)&quot;&quot;&quot;</span><br><span class=\"line\">    return pow(a, (p - 1) // 2, p)</span><br><span class=\"line\"></span><br><span class=\"line\">def tonelli_shanks(n, p):</span><br><span class=\"line\">    &quot;&quot;&quot;Tonelli-Shanks算法求解 x^2 ≡ n (mod p)&quot;&quot;&quot;</span><br><span class=\"line\">    assert legendre_symbol(n, p) == 1, &quot;n 不是模 p 的二次剩余&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 处理 p ≡ 3 (mod 4) 的特殊情况</span><br><span class=\"line\">    if p % 4 == 3:</span><br><span class=\"line\">        return pow(n, (p + 1) // 4, p)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 找到 q 和 s，使得 p-1 = q * 2^s，且 q 为奇数</span><br><span class=\"line\">    q = p - 1</span><br><span class=\"line\">    s = 0</span><br><span class=\"line\">    while q % 2 == 0:</span><br><span class=\"line\">        q //= 2</span><br><span class=\"line\">        s += 1</span><br><span class=\"line\"></span><br><span class=\"line\">    # 找到一个非二次剩余 z</span><br><span class=\"line\">    z = 2</span><br><span class=\"line\">    while legendre_symbol(z, p) != -1:</span><br><span class=\"line\">        z += 1</span><br><span class=\"line\"></span><br><span class=\"line\">    # 初始化变量</span><br><span class=\"line\">    m = s</span><br><span class=\"line\">    c = pow(z, q, p)</span><br><span class=\"line\">    t = pow(n, q, p)</span><br><span class=\"line\">    r = pow(n, (q + 1) // 2, p)</span><br><span class=\"line\"></span><br><span class=\"line\">    while t != 0 and t != 1:</span><br><span class=\"line\">        # 找到最小的 i 使得 t^(2^i) ≡ 1 (mod p)</span><br><span class=\"line\">        t2i = t</span><br><span class=\"line\">        i = 0</span><br><span class=\"line\">        for i in range(1, m):</span><br><span class=\"line\">            t2i = pow(t2i, 2, p)</span><br><span class=\"line\">            if t2i == 1:</span><br><span class=\"line\">                break</span><br><span class=\"line\"></span><br><span class=\"line\">        # 更新变量</span><br><span class=\"line\">        b = pow(c, 2**(m - i - 1), p)</span><br><span class=\"line\">        m = i</span><br><span class=\"line\">        c = pow(b, 2, p)</span><br><span class=\"line\">        t = (t * c) % p</span><br><span class=\"line\">        r = (r * b) % p</span><br><span class=\"line\"></span><br><span class=\"line\">    return r</span><br><span class=\"line\"></span><br><span class=\"line\"># 示例用法</span><br><span class=\"line\">n = 10</span><br><span class=\"line\">p = 13</span><br><span class=\"line\">result = tonelli_shanks(n, p)</span><br><span class=\"line\">print(f&quot;x^2 ≡ &#123;n&#125; (mod &#123;p&#125;) 的一个解是 x ≡ &#123;result&#125; (mod &#123;p&#125;)&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>也可以使用各种库，如sympy</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from sympy.ntheory.residue_ntheory import nthroot_mod</span><br><span class=\"line\"></span><br><span class=\"line\">a = </span><br><span class=\"line\">p = </span><br><span class=\"line\">result = nthroot_mod(a,2,p)</span><br><span class=\"line\">print(result)</span><br></pre></td></tr></table></figure>\n\n<p>这里nthroot_mod函数相当于计算x² ≡ a (mod p)</p>\n<p>后续会写一些关于常用库的常用函数的文章。</p>\n<h2 id=\"中国剩余定理\"><a href=\"#中国剩余定理\" class=\"headerlink\" title=\"中国剩余定理\"></a>中国剩余定理</h2>","categories":[],"tags":[]}