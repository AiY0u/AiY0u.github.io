{"total":4,"pageSize":10,"pageCount":1,"data":[{"title":"CRYPTO中的数论基础（更新中）","slug":"CRYPTO中的数论基础（更新中）","date":"2025-02-03T04:52:07.000Z","updated":"2025-02-08T07:57:10.826Z","comments":true,"path":"api/articles/CRYPTO中的数论基础（更新中）.json","excerpt":"","keywords":null,"cover":"/../images/image-20250207182502113.png","content":"<p>本文持续更新中</p>\n<h2 id=\"数论简介：\"><a href=\"#数论简介：\" class=\"headerlink\" title=\"数论简介：\"></a>数论简介：</h2><p><a href=\"https://baike.baidu.com/item/%E6%95%B0%E8%AE%BA/3700\">数论（number theory），是纯粹数学的分支之一，主要研究整数的性质。</a></p>\n<h2 id=\"模运算\"><a href=\"#模运算\" class=\"headerlink\" title=\"模运算\"></a>模运算</h2><h3 id=\"1-模运算规则\"><a href=\"#1-模运算规则\" class=\"headerlink\" title=\"1. 模运算规则\"></a>1. 模运算规则</h3><p><strong>a mod b    (b&gt;0，且a,b均为整数)</strong>   相当于许多编程语言中的<strong>a % b</strong>,表示a作为被除数，b作为除数时，计算所得到的<strong>余数</strong></p>\n<p>这里强调,除数b必须是正整数，而被除数a可以是负整数</p>\n<h3 id=\"2-整除的概念\"><a href=\"#2-整除的概念\" class=\"headerlink\" title=\"2. 整除的概念\"></a>2. 整除的概念</h3><p>如果a mod b&#x3D; 0，则称b整除a，记作b|a</p>\n<p>如：15&#x2F;5&#x3D;3，则5|15</p>\n<h3 id=\"3-模运算举例\"><a href=\"#3-模运算举例\" class=\"headerlink\" title=\"3. 模运算举例\"></a>3. 模运算举例</h3><p>15点是下午3点，19点是晚上7点，这其实就运用了模运算（x mod 12）</p>\n<p>a为负整数时怎么算呢？</p>\n<p>例如：-11 mod 4</p>\n<p>我们可以让-11不停加上4</p>\n<p>-11+4&#x3D;-7，-7+4&#x3D;-3，-3+4&#x3D;1</p>\n<p>所以-11 mod 4 &#x3D; 1（即-11&#x3D;4*(-3)+1）</p>\n<h2 id=\"最大公约数\"><a href=\"#最大公约数\" class=\"headerlink\" title=\"最大公约数\"></a>最大公约数</h2><h3 id=\"1-公约数和最大公约数的概念\"><a href=\"#1-公约数和最大公约数的概念\" class=\"headerlink\" title=\"1.公约数和最大公约数的概念\"></a>1.公约数和最大公约数的概念</h3><p><strong>设整数a,b 如果存在整数d,使d|a,d|b,则称d是a和b的公因子(或公约数)</strong></p>\n<p><strong>如果  <em>d&gt;0</em>  ,且a和b的所有公因子都整除d,则称d是a和b的  <em>最大公约数</em>  ，记作gcd(a,b)</strong></p>\n<p>哎为什么这里没有限制公因子是正整数还是负整数嘞？</p>\n<p>因为<strong>公因子可正可负可为0</strong>！</p>\n<p>3和6的公因子:+1,-1,+3,-3</p>\n<p>其中gcd(3,6) &#x3D; 3  </p>\n<p>再有就是说，求最大公约数时可以把负号直接去掉来求:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcd(-3,6) = gcd(3,6) = 3 ; gcd(-3,-6) = gcd(3,6) = 3</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"互素\"><a href=\"#互素\" class=\"headerlink\" title=\"互素\"></a>互素</h2><p>定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果gcb(a,b) = 1,称a和b互素</span><br></pre></td></tr></table></figure>\n\n<p>存在这样一个定理:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果gcd(a,b) = d，那么存在整数m,n 使得a=md,b=nd,且gcd(m,n)=1</span><br></pre></td></tr></table></figure>\n\n<p>例如gcd(4,6)&#x3D;2 ,m&#x3D;2,n&#x3D;3,m和n互质</p>\n<p>证明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果gcd(m,n)=t &gt;1，</span><br><span class=\"line\">即m,n有大于1的公约数</span><br><span class=\"line\">那么gcd(a,b)=td,</span><br><span class=\"line\">与gcd(a,b)=d矛盾</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"欧几里得算法-辗转相除法-计算最大公约数\"><a href=\"#欧几里得算法-辗转相除法-计算最大公约数\" class=\"headerlink\" title=\"欧几里得算法(辗转相除法)计算最大公约数\"></a>欧几里得算法(辗转相除法)计算最大公约数</h2><h3 id=\"欧几里得算法的原理\"><a href=\"#欧几里得算法的原理\" class=\"headerlink\" title=\"欧几里得算法的原理\"></a><strong>欧几里得算法的原理</strong></h3><p>不妨设a&gt;&#x3D;b&gt;&#x3D;0</p>\n<p>1.b&#x3D;0时,gcd(a,0)&#x3D;a     <em>任何数都是0的因子，所以这里是a</em></p>\n<p>2.b!&#x3D;0时，求gcd(a,b)，许多情况下我们可以写出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=q*b+r</span><br></pre></td></tr></table></figure>\n\n<p>​\t假设gcd(a,b)&#x3D;t, 那么上式写为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m*t=q*n*t+r</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r=(m-q*n)t</span><br></pre></td></tr></table></figure>\n\n<p>​    </p>\n<p>由此得到：t也是余数r的因子。这个结论对a和b的任意因子都成立，显然也对最大公因子成立</p>\n<p>所以我们知道</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcd(a,b)=gcd(b,r)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"计算过程\"><a href=\"#计算过程\" class=\"headerlink\" title=\"计算过程\"></a>计算过程</h3><p>通过不断缩小问题规模，把求两个数的最大公约数转化为更简单的情况。</p>\n<ol>\n<li>若较小的数是0，答案就是较大的数<ul>\n<li>比如求gcd(8,0)&#x3D;8，因为所有数都能整除0</li>\n</ul>\n</li>\n<li>若两数都不为0，用除法转换问题：<ul>\n<li>用大数除以小数：70 ÷ 15 &#x3D; 4 余 10（写作70 &#x3D; 4×15 +10）</li>\n<li>此时gcd(70,15) &#x3D; gcd(15,10)（关键转换！）</li>\n<li>继续对新数对重复这个过程</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"实操\"><a href=\"#实操\" class=\"headerlink\" title=\"实操\"></a><strong>实操</strong></h3><p>​\tgcd(70,15)&#x3D;gcd(15,10)&#x3D;gcd(10,5)&#x3D;gcd(5,0)&#x3D;5</p>\n<ol>\n<li>70 ÷ 15 &#x3D; 4 余10 → 转为求gcd(15,10)</li>\n<li>15 ÷ 10 &#x3D; 1 余5 → 转为求gcd(10,5)</li>\n<li>10 ÷ 5 &#x3D; 2 余0 → 转为求gcd(5,0)</li>\n<li>出现0时，答案就是剩下的5</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">gcd</span>(<span class=\"params\">a,b</span>):</span><br><span class=\"line\">    <span class=\"keyword\">while</span> b!=<span class=\"number\">0</span>:</span><br><span class=\"line\">        t = a % b</span><br><span class=\"line\">        a = b</span><br><span class=\"line\">        b = t</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\">a = ？</span><br><span class=\"line\">b = ？</span><br><span class=\"line\"><span class=\"built_in\">print</span>(gcd(a,b))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"扩展的欧几里得算法\"><a href=\"#扩展的欧几里得算法\" class=\"headerlink\" title=\"扩展的欧几里得算法\"></a>扩展的欧几里得算法</h2><p><strong>扩展欧几里得算法</strong>是欧几里得算法的升级版，它不仅计算两个数的最大公约数（GCD），还能找到一组关键系数（称为<strong>贝祖系数</strong>），使得这两个数的线性组合等于它们的最大公约数。</p>\n<h3 id=\"贝祖定理：\"><a href=\"#贝祖定理：\" class=\"headerlink\" title=\"贝祖定理：\"></a><strong>贝祖定理</strong>：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">若 d=gcd⁡(a,b)，则存在整数 s,t使得 as+bt=d</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">特别地，若 gcd⁡(a,b)=1，则方程 as+bt=1 有解（即 a 和 b 互质时存在逆元）。</span><br><span class=\"line\">推论：方程 as+bt=v 有解当且仅当 d∣v（即 v 是 d 的倍数）。</span><br></pre></td></tr></table></figure>\n\n<p>而扩展的欧几里得算法就是用来计算上述定理中的s和t</p>\n<h3 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a>原理：</h3><p>根据欧几里得算法的逆过程，这里以gcd(70,15)为例</p>\n<p>前文已经写出了欧几里得算法的过程，我们只需根据它一步一步回代</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5=15×1−10×1</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">其中 10=70×1+15×(−4)，代入得：</span><br><span class=\"line\"></span><br><span class=\"line\">5=15×1−(70×1+15×(−4))×1=70×(−1)+15×5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def extended_gcd(a, b):</span><br><span class=\"line\">    if b == 0:</span><br><span class=\"line\">        return (a, 1, 0)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        d, s_prime, t_prime = extended_gcd(b, a % b)</span><br><span class=\"line\">        s = t_prime</span><br><span class=\"line\">        t = s_prime - (a // b) * t_prime</span><br><span class=\"line\">        return (d, s, t)</span><br><span class=\"line\"></span><br><span class=\"line\">d, s, t = extended_gcd(70, 15)</span><br><span class=\"line\">print(f&quot;gcd(70,15)=&#123;d&#125;, 系数 s=&#123;s&#125;, t=&#123;t&#125;&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t施工区域</p>\n<h2 id=\"最小公倍数\"><a href=\"#最小公倍数\" class=\"headerlink\" title=\"最小公倍数\"></a>最小公倍数</h2><p>引入：天干地支纪年法中，天干有10个，地支有12个</p>\n<p>我们知道60年1甲子，天干循环一次周期是10，地支循环周期是12；</p>\n<p>从一次出现甲子到下一次出现甲子，不仅需要天干中出现甲，地支中出现子，则刚好需要天干循环整数次，地支循环整数次，显然，这就变成了一个最小公倍数问题，每60年能让天干循环6次，地支循环5次<br>$$<br>设a,b∈Z，如果m∈Z分别是a和b的倍数，m称为a和b的公倍数<br>$$</p>\n<p>$$<br>a,b≠0，如果m是所有正的公倍数中最小的，那么m叫做a和b的最小公倍数，记为m&#x3D;lcm(a,b)<br>$$</p>\n<p>$$<br>如果a&#x3D;0或者b&#x3D;0：lcm(a,b)&#x3D;0<br>$$</p>\n<p><strong>lcm(a,b)&#x3D;ab&#x2F;gcd(a,b)</strong></p>\n<h2 id=\"同余\"><a href=\"#同余\" class=\"headerlink\" title=\"同余\"></a>同余</h2><h2 id=\"费马小定理\"><a href=\"#费马小定理\" class=\"headerlink\" title=\"费马小定理\"></a>费马小定理</h2><h2 id=\"模逆元\"><a href=\"#模逆元\" class=\"headerlink\" title=\"模逆元\"></a>模逆元</h2><h2 id=\"二次剩余\"><a href=\"#二次剩余\" class=\"headerlink\" title=\"二次剩余\"></a>二次剩余</h2><p>一个整数x对另一个整数p的二次剩余指的是计算x² mod p的结果（x的平方除以p得到的余数）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当存在一个整数x使得x² ≡ a mod p,称a是模p的二次剩余</span><br><span class=\"line\"></span><br><span class=\"line\">当不存在一个整数x使得x² ≡ a mod p,称a是模p的二次非剩余</span><br></pre></td></tr></table></figure>\n\n<p>它还有这样的运算性质：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二次剩余 * 二次剩余 = 二次剩余</span><br><span class=\"line\"></span><br><span class=\"line\">二次剩余 * 二次非剩余 = 二次非剩余</span><br><span class=\"line\"></span><br><span class=\"line\">二次非剩余 * 二次非剩余 = 二次剩余</span><br></pre></td></tr></table></figure>\n\n<p>检验整数是否是二次剩余参见下文勒让德符号</p>\n<h2 id=\"勒让德符号\"><a href=\"#勒让德符号\" class=\"headerlink\" title=\"勒让德符号\"></a>勒让德符号</h2><p><strong>勒让德符号(Legendre Symbol)<strong>提供了一种有效的方法来确定整数a是否是模</strong>奇数素数p</strong>的二次余数 </p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%8B%92%E8%AE%A9%E5%BE%B7%E7%AC%A6%E5%8F%B7\">勒让德符号-维基百科</a></p>\n<p><img src=\"/../images/image-20250207182502113.png\" alt=\"image-20250207182502113\"></p>\n<p>以cryptohack中的题目为例：</p>\n<p>题目要求：</p>\n<p>Now for the flag. Given the following 1024 bit prime and 10 integers,  find the quadratic residue and then calculate its square root; the  square root is your flag. Of the two possible roots, submit the larger  one as your answer.</p>\n<p>给定1024bit的质数和10个整数，找到二次剩余并且计算它的模平方根，取较大的一个作为flag</p>\n<p><img src=\"/../images/image-20250208144201545.png\" alt=\"image-20250208144201545\"></p>\n<p>我们首先根据勒让德符号，得到哪一个整数是二次剩余。代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139</span><br><span class=\"line\">ints = []#篇幅有限，省略掉了</span><br><span class=\"line\">for i in ints:</span><br><span class=\"line\">    a_p = pow(i,(p-1)//2,p)</span><br><span class=\"line\">    if(a_p == 1):</span><br><span class=\"line\">        print(i)</span><br><span class=\"line\">        a = i</span><br><span class=\"line\">print(a,&quot;为二次剩余&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>这里提一句，python判断是否是二次剩余的写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if pow(n,(p-1)//2,p) == 1:</span><br><span class=\"line\">\tprint(&quot;二次剩余&quot;)</span><br><span class=\"line\">if pow(n,(p-1)//2,p) == p - 1:</span><br><span class=\"line\">\tprint(&quot;二次非剩余&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>第三行写的是p-1，因为python的<strong>pow函数计算结果不会为负。</strong></p>\n<p>之后求它的模平方根，需要用到一定的代数运算。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#求a模p意义下的平方根</span><br><span class=\"line\">#因为a**[(p-1)/2] ≡ 1 (mod p)</span><br><span class=\"line\">#所以a**[(p+1)/2] ≡ a (mod p)</span><br><span class=\"line\">#所以a**[(p+1)/4] ≡ a**(1/2) (mod p)</span><br><span class=\"line\"># 计算a**[(p+1)/4] mod p</span><br><span class=\"line\">print(pow(a,(p+1)//4,p))</span><br><span class=\"line\">#注意这里需要确定(p+1)/4是整数，即p mod 4 = 3</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Tonelli-Shanks算法\"><a href=\"#Tonelli-Shanks算法\" class=\"headerlink\" title=\"Tonelli-Shanks算法\"></a>Tonelli-Shanks算法</h2><p>**Tonelli-Shanks算法(托内利-尚克斯算法)**可以计算模素数下的平方根。</p>\n<p>python实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def legendre_symbol(a, p):</span><br><span class=\"line\">    &quot;&quot;&quot;计算勒让德符号 (a/p)&quot;&quot;&quot;</span><br><span class=\"line\">    return pow(a, (p - 1) // 2, p)</span><br><span class=\"line\"></span><br><span class=\"line\">def tonelli_shanks(n, p):</span><br><span class=\"line\">    &quot;&quot;&quot;Tonelli-Shanks算法求解 x^2 ≡ n (mod p)&quot;&quot;&quot;</span><br><span class=\"line\">    assert legendre_symbol(n, p) == 1, &quot;n 不是模 p 的二次剩余&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 处理 p ≡ 3 (mod 4) 的特殊情况</span><br><span class=\"line\">    if p % 4 == 3:</span><br><span class=\"line\">        return pow(n, (p + 1) // 4, p)</span><br><span class=\"line\"></span><br><span class=\"line\">    # 找到 q 和 s，使得 p-1 = q * 2^s，且 q 为奇数</span><br><span class=\"line\">    q = p - 1</span><br><span class=\"line\">    s = 0</span><br><span class=\"line\">    while q % 2 == 0:</span><br><span class=\"line\">        q //= 2</span><br><span class=\"line\">        s += 1</span><br><span class=\"line\"></span><br><span class=\"line\">    # 找到一个非二次剩余 z</span><br><span class=\"line\">    z = 2</span><br><span class=\"line\">    while legendre_symbol(z, p) != -1:</span><br><span class=\"line\">        z += 1</span><br><span class=\"line\"></span><br><span class=\"line\">    # 初始化变量</span><br><span class=\"line\">    m = s</span><br><span class=\"line\">    c = pow(z, q, p)</span><br><span class=\"line\">    t = pow(n, q, p)</span><br><span class=\"line\">    r = pow(n, (q + 1) // 2, p)</span><br><span class=\"line\"></span><br><span class=\"line\">    while t != 0 and t != 1:</span><br><span class=\"line\">        # 找到最小的 i 使得 t^(2^i) ≡ 1 (mod p)</span><br><span class=\"line\">        t2i = t</span><br><span class=\"line\">        i = 0</span><br><span class=\"line\">        for i in range(1, m):</span><br><span class=\"line\">            t2i = pow(t2i, 2, p)</span><br><span class=\"line\">            if t2i == 1:</span><br><span class=\"line\">                break</span><br><span class=\"line\"></span><br><span class=\"line\">        # 更新变量</span><br><span class=\"line\">        b = pow(c, 2**(m - i - 1), p)</span><br><span class=\"line\">        m = i</span><br><span class=\"line\">        c = pow(b, 2, p)</span><br><span class=\"line\">        t = (t * c) % p</span><br><span class=\"line\">        r = (r * b) % p</span><br><span class=\"line\"></span><br><span class=\"line\">    return r</span><br><span class=\"line\"></span><br><span class=\"line\"># 示例用法</span><br><span class=\"line\">n = 10</span><br><span class=\"line\">p = 13</span><br><span class=\"line\">result = tonelli_shanks(n, p)</span><br><span class=\"line\">print(f&quot;x^2 ≡ &#123;n&#125; (mod &#123;p&#125;) 的一个解是 x ≡ &#123;result&#125; (mod &#123;p&#125;)&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>也可以使用各种库，如sympy</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from sympy.ntheory.residue_ntheory import nthroot_mod</span><br><span class=\"line\"></span><br><span class=\"line\">a = </span><br><span class=\"line\">p = </span><br><span class=\"line\">result = nthroot_mod(a,2,p)</span><br><span class=\"line\">print(result)</span><br></pre></td></tr></table></figure>\n\n<p>这里nthroot_mod函数相当于计算x² ≡ a (mod p)</p>\n<p>关于常用库的常用函数的文章火热筹备中。</p>\n<h2 id=\"中国剩余定理\"><a href=\"#中国剩余定理\" class=\"headerlink\" title=\"中国剩余定理\"></a>中国剩余定理</h2>","text":"本文持续更新中数论简介：数论（number theory），是纯粹数学的分支之一，主要研究整数的性质。模运算1. 模运算规则a mod b    (b&gt;0，且a,b均为整数)   相当于许多编程语言中的a % b,表示a作为被除数，b作为除数时，计算所得到的余数这里强调,除","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"CRYPTO中的XOR问题","slug":"CRYPTO中的XOR问题","date":"2025-02-02T04:53:40.000Z","updated":"2025-02-04T11:49:33.696Z","comments":true,"path":"api/articles/CRYPTO中的XOR问题.json","excerpt":"","keywords":null,"cover":"/../images/image-20250204192002493.png","content":"<p>XOR是CTFer在做题中常见的问题，本文分享一下我在做题过程中遇到的经典问题</p>\n<h2 id=\"什么是XOR\"><a href=\"#什么是XOR\" class=\"headerlink\" title=\"什么是XOR\"></a>什么是XOR</h2><p>XOR即”异或运算“，它在数学表达式中常常写作’’⊕’’，在常见的几种编程语言中，则是用符号’’^’’来表示。</p>\n<p>XOR运算遵循这样的规则：</p>\n<p>1⊕1 &#x3D; 0</p>\n<p>0⊕0 &#x3D; 0</p>\n<p>1⊕0 &#x3D; 1</p>\n<p>0⊕1 &#x3D; 1</p>\n<p>在实际运算中，它是按位运算的。现有二进制10010和11001，二者异或的结果为01011。</p>\n<h2 id=\"XOR的运算性质\"><a href=\"#XOR的运算性质\" class=\"headerlink\" title=\"XOR的运算性质\"></a>XOR的运算性质</h2><p>XOR运算具有</p>\n<p>1）交换律</p>\n<p>2）结合律</p>\n<p>3）归零律：A⊕A&#x3D;0</p>\n<p>4）恒等律：A⊕0&#x3D;A</p>\n<p>由其归零率和恒等率我们还可以推出：</p>\n<p>A⊕B&#x3D;C</p>\n<p>即A⊕B⊕B&#x3D;C⊕B</p>\n<p>即A&#x3D;C⊕B</p>\n<p>这就说明了为什么单单使用XOR，属于对称密码。假设A是密文，B是密钥，经过上面的步骤可以看出只要知道密钥B，就能将密文和明文相互转化。</p>\n<h2 id=\"XOR题型举例\"><a href=\"#XOR题型举例\" class=\"headerlink\" title=\"XOR题型举例\"></a>XOR题型举例</h2><h3 id=\"利用运算性质\"><a href=\"#利用运算性质\" class=\"headerlink\" title=\"利用运算性质\"></a>利用运算性质</h3><p><em>本题来源于cryptohack</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KEY1 = a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313</span><br><span class=\"line\">KEY2 ^ KEY1 = 37dcb292030faa90d07eec17e3b1c6d8daf94c35d4c9191a5e1e</span><br><span class=\"line\">KEY2 ^ KEY3 = c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1</span><br><span class=\"line\">FLAG ^ KEY1 ^ KEY3 ^ KEY2 = 04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf </span><br></pre></td></tr></table></figure>\n\n<p>求FLAG只需让4式异或1式和3式</p>\n<p>python实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">KEY1 = <span class=\"built_in\">bytes</span>.fromhex(<span class=\"string\">&#x27;a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313&#x27;</span>)</span><br><span class=\"line\">KEY2_KEY1 = <span class=\"built_in\">bytes</span>.fromhex(<span class=\"string\">&#x27;37dcb292030faa90d07eec17e3b1c6d8daf94c35d4c9191a5e1e&#x27;</span>)</span><br><span class=\"line\">KEY2_KEY3 = <span class=\"built_in\">bytes</span>.fromhex(<span class=\"string\">&#x27;c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1&#x27;</span>)</span><br><span class=\"line\">FLAG_KEY1_KEY3_KEY2 = <span class=\"built_in\">bytes</span>.fromhex(<span class=\"string\">&#x27;04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf&#x27;</span>)</span><br><span class=\"line\">step1 = xor(FLAG_KEY1_KEY3_KEY2,KEY1)</span><br><span class=\"line\">step2 = xor(step1,KEY2_KEY3)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(step2)</span><br></pre></td></tr></table></figure>\n\n<p>注：1. 使用了pwntools库中的xor()函数</p>\n<p>​\t\t2.bytes.fromhex()函数的作用是将十六进制字符组成的字符串转化为字节序列，即’a6c8b6’转化为0xa6 0xc8 0xb6的序列</p>\n<h3 id=\"碰撞已知的明文片段\"><a href=\"#碰撞已知的明文片段\" class=\"headerlink\" title=\"碰撞已知的明文片段\"></a>碰撞已知的明文片段</h3><p><img src=\"/../images/image-20250204192002493.png\" alt=\"image-20250204192002493\"></p>\n<p>本题我们已知密钥仅为一个字节，又知道最终flag为crypto{xxxxxx}的形式</p>\n<p>根据XOR运算的性质，我们只需要让密文首个字节与字母’c’异或，就能得到密钥</p>\n<p>python实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import *</span><br><span class=\"line\">m = &#x27;73626960647f6b206821204f21254f7d694f7624662065622127234f726927756d&#x27;</span><br><span class=\"line\">m_bytes = bytes.fromhex(m)</span><br><span class=\"line\">key = xor(0x73,&#x27;c&#x27;)</span><br><span class=\"line\">print(key)</span><br><span class=\"line\">p = xor(m_bytes,key)</span><br><span class=\"line\">print(p)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对图片的XOR\"><a href=\"#对图片的XOR\" class=\"headerlink\" title=\"对图片的XOR\"></a><em>对图片的XOR</em></h3><p>基本原理：图片由许多像素点排列组成，我们可以把每个像素点的灰度或RGB(red,green,blue,可以认为每个像素点的颜色是由这三种颜色不同比例混合而成的)的数值当作异或的对象。将异或得到的数值再转化为灰度或RGB，形成新的图片。</p>\n<p>常用的工具：python的PIL库</p>\n<p>例题来自cryptohack，感兴趣可自行查看</p>\n<p><img src=\"/../images/image-20250204193936704.png\" alt=\"image-20250204193936704\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from PIL import Image</span><br><span class=\"line\">image1 = Image.open(&quot;F:\\pythonscript\\cryptohack\\Lemur_XOR\\lemur_ed66878c338e662d3473f0d98eedbd0d.png&quot;)</span><br><span class=\"line\">image2 = Image.open(&quot;F:\\pythonscript\\cryptohack\\Lemur_XOR\\\\flag_7ae18c704272532658c10b5faad06d74.png&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">#生成可操作的对象，pim类似于矩阵，通过坐标值来操控每个像素</span><br><span class=\"line\">pim1 = image1.load()</span><br><span class=\"line\">pim2 = image2.load()</span><br><span class=\"line\"></span><br><span class=\"line\">width,height=image1.size</span><br><span class=\"line\"></span><br><span class=\"line\">for i in range(width):</span><br><span class=\"line\">    for j in range(height):</span><br><span class=\"line\">        r1,g1,b1 = pim1[i,j]</span><br><span class=\"line\">        r2,g2,b2 = pim2[i,j]</span><br><span class=\"line\">        pim1[i,j] = (r1^r2, g1^g2, b1^b2)</span><br><span class=\"line\"></span><br><span class=\"line\">image1.show()</span><br></pre></td></tr></table></figure>\n\n<p>注：Image.open()函数即打开图片文件</p>\n<p>​\t\t.load()函数生成一个矩阵，通过坐标值来访问图片中的每个像素</p>\n<p>​\t\t.size能分别得出图片的宽和高（像素点个数）</p>\n<p>​\t\tr1,g1,b1 &#x3D; pim1[i,j]这一句是得到[i,j]位置处的RGB值</p>\n<p>​\t\t.show()函数负责弹窗展示图片</p>\n<p>感觉这一题更像是misc会出的东西。</p>\n","text":"XOR是CTFer在做题中常见的问题，本文分享一下我在做题过程中遇到的经典问题什么是XORXOR即”异或运算“，它在数学表达式中常常写作’’⊕’’，在常见的几种编程语言中，则是用符号’’^’’来表示。XOR运算遵循这样的规则：1⊕1 &#x3D; 00⊕0 &#x3D; 01⊕0","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"AiY0u的第一篇文章","slug":"试写第一篇文章","date":"2025-01-25T13:30:53.000Z","updated":"2025-01-25T14:25:02.794Z","comments":true,"path":"api/articles/试写第一篇文章.json","excerpt":"","keywords":null,"cover":"/../images/69b46eaad741237bd0dfa1852adbc289.png","content":"<h2 id=\"part-1-表达一下激动之情\"><a href=\"#part-1-表达一下激动之情\" class=\"headerlink\" title=\"part.1  表达一下激动之情\"></a>part.1  表达一下激动之情</h2><p>本文仅仅是写作尝试，<del>让我看看到底怎么个事儿</del></p>\n<p>先这样再这样再那样</p>\n<p>最后</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d -g</span><br></pre></td></tr></table></figure>\n\n<p>然后我的文章就在博客上了么？</p>\n<p>在了么？</p>\n<p><del>窝趣这简直是魔法！</del></p>\n<h2 id=\"part-2-关于AiY0u\"><a href=\"#part-2-关于AiY0u\" class=\"headerlink\" title=\"part.2  关于AiY0u\"></a>part.2  关于AiY0u</h2><p>是的没错，博客是新搭建的，AiY0u这个名字也是新起的。</p>\n<p>本人是大一小登，学习大数据专业，同时对隔壁信安的CTF很感兴趣，这个博客以后会记录本人在信息安全和大数据方面学到的点点滴滴。</p>\n<p><em>写博客其实也是学长给的任务</em></p>\n<h2 id=\"part-3-发表这篇文章遇到的麻烦\"><a href=\"#part-3-发表这篇文章遇到的麻烦\" class=\"headerlink\" title=\"part.3  发表这篇文章遇到的麻烦\"></a>part.3  发表这篇文章遇到的麻烦</h2><p>好吧事实上发第一篇文章时遇到了不小的麻烦，</p>\n<p><strong>第一个是我发现更换了主题之后，页面图标改不动。</strong><img src=\"/../images/69b46eaad741237bd0dfa1852adbc289.png\" alt=\"69b46eaad741237bd0dfa1852adbc289\"></p>\n<p>就照着步骤走的，但是替换了图片之后，页面图标还是不变。尝试了好久，学长告诉我按F12开启禁用http缓存。然后它就好了，嘿，神奇。</p>\n<p><strong>再一个是写完文章想要发上去，</strong></p>\n<p><strong>在执行<code>hexo d</code>时出现了Spawn failed的报错</strong></p>\n<p><img src=\"/../images/image-20250125215759604.png\" alt=\"image-20250125215759604\"></p>\n<p>我使用了<a href=\"https://blog.csdn.net/hannah2233/article/details/119976392\">这篇文章</a>的解决办法二</p>\n<p>现在还是懵懵懂懂，之后俺会努力哒！</p>\n","text":"part.1  表达一下激动之情本文仅仅是写作尝试，让我看看到底怎么个事儿先这样再这样再那样最后1<br>hexo d -g<br>然后我的文章就在博客上了么？在了么？窝趣这简直是魔法！part.2  关于AiY0u是的没错，博客是新搭建的，AiY0u这个名字也是新起的。本人是大","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2025-01-25T09:30:26.963Z","updated":"2025-01-25T09:30:26.963Z","comments":true,"path":"api/articles/hello-world.json","excerpt":"","keywords":null,"cover":null,"content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the ","raw":null,"photos":[],"categories":[],"tags":[]}]}